(window.webpackJsonp=window.webpackJsonp||[]).push([[43],{566:function(e,a,t){"use strict";t.r(a);var s=t(2),v=Object(s.a)({},(function(){var e=this,a=e.$createElement,t=e._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h2",{attrs:{id:"cookie"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#cookie"}},[e._v("#")]),e._v(" cookie")]),e._v(" "),t("h3",{attrs:{id:"cookie如何认证"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#cookie如何认证"}},[e._v("#")]),e._v(" cookie如何认证")]),e._v(" "),t("ol",[t("li",[t("p",[e._v("用户输入用户名与密码，发送给服务器。")])]),e._v(" "),t("li",[t("p",[e._v("服务器验证用户名和密码，正确的就创建一个会话（session），同时会把这个"),t("strong",[e._v("会话的ID")]),e._v("保存到客户端浏览器中，因为保存的地方是浏览器的"),t("code",[e._v("cookie")]),e._v("，所以这种认证方式叫做基于"),t("code",[e._v("cookie")]),e._v("的认证方式。")])]),e._v(" "),t("li",[t("p",[e._v("后续的请求中，浏览器会发送会话ID到服务器，服务器上如果能找到对应的ID的会话，那么服务器就会返回需要的数据给浏览器。")])]),e._v(" "),t("li",[t("p",[e._v("当用户退出登录，会话会同时在客户端和服务器端被销毁。")])])]),e._v(" "),t("h3",{attrs:{id:"cookie认证方式的不足之处"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#cookie认证方式的不足之处"}},[e._v("#")]),e._v(" cookie认证方式的不足之处")]),e._v(" "),t("ol",[t("li",[t("p",[e._v("服务器要为每个用户保留session信息，连接用户过多会造成服务器内存压力过大。")])]),e._v(" "),t("li",[t("p",[e._v("适合单一域名，不适合第三方请求。")])])]),e._v(" "),t("h2",{attrs:{id:"token"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#token"}},[e._v("#")]),e._v(" token")]),e._v(" "),t("h3",{attrs:{id:"token的认证过程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#token的认证过程"}},[e._v("#")]),e._v(" token的认证过程")]),e._v(" "),t("ol",[t("li",[t("p",[e._v("用户输入用户名和密码，发送给服务器。")])]),e._v(" "),t("li",[t("p",[e._v("服务器验证用户名和密码，正确的话就返回一个"),t("strong",[e._v("签名过的token")]),e._v("（token 可以认为就是个长长的字符串），浏览器客户端拿到这个token。")])]),e._v(" "),t("li",[t("p",[e._v("后续每次请求中，"),t("strong",[e._v("浏览器会把token作为http header发送给服务器")]),e._v("，服务器验证签名是否有效，如果有效那么认证就成功，可以返回客户端需要的数据。")])]),e._v(" "),t("li",[t("p",[e._v("一旦用户退出登录，只需要客户端销毁token即可，服务器端不需要任何操作。")])])]),e._v(" "),t("h3",{attrs:{id:"token认证方式的特点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#token认证方式的特点"}},[e._v("#")]),e._v(" token认证方式的特点")]),e._v(" "),t("p",[e._v("这种方式的特点就是客户端的token中自己保留有大量信息，服务器没有存储这些信息，而只负责验证，不必进行数据库查询，"),t("strong",[e._v("执行效率大大提高")]),e._v("。")]),e._v(" "),t("h2",{attrs:{id:"jwt"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#jwt"}},[e._v("#")]),e._v(" JWT")]),e._v(" "),t("h3",{attrs:{id:"jwt介绍"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#jwt介绍"}},[e._v("#")]),e._v(" JWT介绍")]),e._v(" "),t("ol",[t("li",[t("p",[e._v("JWT是"),t("code",[e._v("json web token")]),e._v("缩写。它将用户信息加密到token里，服务器不保存任何用户信息。服务器通过使用保存的密钥验证token的正确性，只要正确即通过验证。")])]),e._v(" "),t("li",[t("p",[e._v("优点是在分布式系统中，很好地解决了单点登录问题，很容易解决了"),t("code",[e._v("session")]),e._v("共享的问题。jwt长度较小，且可以使用URL传输(URL safe)。不像"),t("code",[e._v("cookies")]),e._v("只能在web环境起作用。JWT可以同时使用在web环境和RESTfull的接口。")])]),e._v(" "),t("li",[t("p",[e._v("缺点是无法作废已颁布的令牌/不易应对数据过期。")])])]),e._v(" "),t("h3",{attrs:{id:"jwt组成"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#jwt组成"}},[e._v("#")]),e._v(" JWT组成")]),e._v(" "),t("p",[e._v("JWT包含三个部分： "),t("strong",[e._v("Header头部")]),e._v("，"),t("strong",[e._v("Payload负载")]),e._v("和"),t("strong",[e._v("Signature签名")]),e._v("。由三部分生成token，三部分之间用“.”号做分割。")]),e._v(" "),t("p",[e._v("列如 ： "),t("code",[e._v("eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c")])]),e._v(" "),t("h4",{attrs:{id:"header"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#header"}},[e._v("#")]),e._v(" Header")]),e._v(" "),t("p",[e._v("在Header中通常包含了两部分：")]),e._v(" "),t("ul",[t("li",[e._v("type：代表token的类型，这里使用的是JWT类型。")]),e._v(" "),t("li",[e._v("alg:使用的Hash算法，例如HMAC SHA256或RSA.")])]),e._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('{\n    "alg": "HS256",\n    "typ": "JWT"\n}\n')])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br"),t("span",{staticClass:"line-number"},[e._v("2")]),t("br"),t("span",{staticClass:"line-number"},[e._v("3")]),t("br"),t("span",{staticClass:"line-number"},[e._v("4")]),t("br")])]),t("p",[e._v("这会被经过base64Url编码形成第一部分")]),e._v(" "),t("h4",{attrs:{id:"payload"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#payload"}},[e._v("#")]),e._v(" Payload")]),e._v(" "),t("p",[e._v("token的第二个部分是荷载信息，它包含一些声明Claim(实体的描述，通常是一个User信息，还包括一些其他的元数据)\n声明分三类:")]),e._v(" "),t("ul",[t("li",[e._v("Reserved Claims,这是一套预定义的声明，并不是必须的,这是一套易于使用、操作性强的声明。包括："),t("code",[e._v("iss(issuer)")]),e._v("、"),t("code",[e._v("exp(expiration time)")]),e._v("、"),t("code",[e._v("sub(subject)")]),e._v("、"),t("code",[e._v("aud(audience)")]),e._v("等")]),e._v(" "),t("li",[e._v("Plubic Claims,")]),e._v(" "),t("li",[e._v("Private Claims,交换信息的双方自定义的声明")])]),e._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('{\n    "sub": "1234567890",\n    "name": "John Doe",\n    "admin": true\n}\n')])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br"),t("span",{staticClass:"line-number"},[e._v("2")]),t("br"),t("span",{staticClass:"line-number"},[e._v("3")]),t("br"),t("span",{staticClass:"line-number"},[e._v("4")]),t("br"),t("span",{staticClass:"line-number"},[e._v("5")]),t("br")])]),t("p",[e._v("同样经过Base64Url编码后形成第二部分")]),e._v(" "),t("h4",{attrs:{id:"signature"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#signature"}},[e._v("#")]),e._v(" signature")]),e._v(" "),t("p",[e._v("使用header中指定的算法将编码后的header、编码后的payload、一个secret进行加密。")]),e._v(" "),t("p",[e._v("例如使用的是HMAC SHA256算法，大致流程类似于:")]),e._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('HMACSHA256( base64UrlEncode(header) + "." + base64UrlEncode(payload), secret)\n')])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br")])]),t("p",[e._v("这个signature字段被用来确认JWT信息的发送者是谁，并保证信息没有被修改")]),e._v(" "),t("h3",{attrs:{id:"为什么使用jwt"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#为什么使用jwt"}},[e._v("#")]),e._v(" 为什么使用JWT")]),e._v(" "),t("p",[e._v("相比XML格式，JSON更加"),t("strong",[e._v("简洁")]),e._v("，编码之后"),t("strong",[e._v("更小")]),e._v("，这使得JWT比SAML更加简洁，更加"),t("strong",[e._v("适合在HTML和HTTP环境中传")]),e._v("递。 在安全性方面，SWT只能够使用HMAC算法和共享的对称秘钥进行签名，而JWT和SAML token则可以使用X.509认证的公私秘钥对进行签名。与简单的JSON相比，XML和XML数字签名会引入复杂的安全漏洞。 因为JSON可以直接映射为对象，在大多数编程语言中都提供了JSON解析器，而XML则没有这么自然的文档-对象映射关系，这就使得使用JWT比SAML更方便 "),t("code",[e._v("java json web token")]),e._v("工具类")])])}),[],!1,null,null,null);a.default=v.exports}}]);